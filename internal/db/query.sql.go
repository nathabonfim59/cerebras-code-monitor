// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const getBaselineAverage = `-- name: GetBaselineAverage :one
SELECT id, organization_id, model_name, time_window, avg_tokens_per_period, avg_requests_per_period, avg_burn_rate_tokens, std_deviation_tokens, std_deviation_requests, sample_count, last_updated, period_days FROM baseline_averages
WHERE organization_id = ?
AND model_name = ?
AND time_window = ?
LIMIT 1
`

type GetBaselineAverageParams struct {
	OrganizationID string `json:"organization_id"`
	ModelName      string `json:"model_name"`
	TimeWindow     string `json:"time_window"`
}

func (q *Queries) GetBaselineAverage(ctx context.Context, arg GetBaselineAverageParams) (BaselineAverage, error) {
	row := q.db.QueryRowContext(ctx, getBaselineAverage, arg.OrganizationID, arg.ModelName, arg.TimeWindow)
	var i BaselineAverage
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ModelName,
		&i.TimeWindow,
		&i.AvgTokensPerPeriod,
		&i.AvgRequestsPerPeriod,
		&i.AvgBurnRateTokens,
		&i.StdDeviationTokens,
		&i.StdDeviationRequests,
		&i.SampleCount,
		&i.LastUpdated,
		&i.PeriodDays,
	)
	return i, err
}

const getLatestUsageSnapshot = `-- name: GetLatestUsageSnapshot :one
SELECT id, timestamp, organization_id, model_name, tokens_used, tokens_limit, tokens_remaining, requests_used, requests_limit, requests_remaining, reset_requests_seconds, reset_tokens_seconds, data_source, is_complete FROM usage_snapshots
WHERE organization_id = ? AND model_name = ?
ORDER BY timestamp DESC
LIMIT 1
`

type GetLatestUsageSnapshotParams struct {
	OrganizationID string `json:"organization_id"`
	ModelName      string `json:"model_name"`
}

func (q *Queries) GetLatestUsageSnapshot(ctx context.Context, arg GetLatestUsageSnapshotParams) (UsageSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getLatestUsageSnapshot, arg.OrganizationID, arg.ModelName)
	var i UsageSnapshot
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.OrganizationID,
		&i.ModelName,
		&i.TokensUsed,
		&i.TokensLimit,
		&i.TokensRemaining,
		&i.RequestsUsed,
		&i.RequestsLimit,
		&i.RequestsRemaining,
		&i.ResetRequestsSeconds,
		&i.ResetTokensSeconds,
		&i.DataSource,
		&i.IsComplete,
	)
	return i, err
}

const getUnacknowledgedAlerts = `-- name: GetUnacknowledgedAlerts :many
SELECT id, timestamp, organization_id, model_name, alert_type, severity, metric_name, metric_value, threshold_value, message, acknowledged, acknowledged_at FROM alerts
WHERE organization_id = ?
AND acknowledged = 0
ORDER BY timestamp DESC
`

func (q *Queries) GetUnacknowledgedAlerts(ctx context.Context, organizationID string) ([]Alert, error) {
	rows, err := q.db.QueryContext(ctx, getUnacknowledgedAlerts, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alert
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.OrganizationID,
			&i.ModelName,
			&i.AlertType,
			&i.Severity,
			&i.MetricName,
			&i.MetricValue,
			&i.ThresholdValue,
			&i.Message,
			&i.Acknowledged,
			&i.AcknowledgedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageMetrics = `-- name: GetUsageMetrics :many
SELECT id, timestamp, organization_id, model_name, time_window, total_tokens_used, total_requests_used, avg_burn_rate_tokens, peak_burn_rate_tokens, avg_burn_rate_requests, is_above_average, deviation_percentage, snapshot_count FROM usage_metrics
WHERE organization_id = ?
AND model_name = ?
AND time_window = ?
ORDER BY timestamp DESC
LIMIT ?
`

type GetUsageMetricsParams struct {
	OrganizationID string `json:"organization_id"`
	ModelName      string `json:"model_name"`
	TimeWindow     string `json:"time_window"`
	Limit          int64  `json:"limit"`
}

func (q *Queries) GetUsageMetrics(ctx context.Context, arg GetUsageMetricsParams) ([]UsageMetric, error) {
	rows, err := q.db.QueryContext(ctx, getUsageMetrics,
		arg.OrganizationID,
		arg.ModelName,
		arg.TimeWindow,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsageMetric
	for rows.Next() {
		var i UsageMetric
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.OrganizationID,
			&i.ModelName,
			&i.TimeWindow,
			&i.TotalTokensUsed,
			&i.TotalRequestsUsed,
			&i.AvgBurnRateTokens,
			&i.PeakBurnRateTokens,
			&i.AvgBurnRateRequests,
			&i.IsAboveAverage,
			&i.DeviationPercentage,
			&i.SnapshotCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageSnapshotsInTimeWindow = `-- name: GetUsageSnapshotsInTimeWindow :many
SELECT id, timestamp, organization_id, model_name, tokens_used, tokens_limit, tokens_remaining, requests_used, requests_limit, requests_remaining, reset_requests_seconds, reset_tokens_seconds, data_source, is_complete FROM usage_snapshots
WHERE timestamp > datetime('now', ?)
AND organization_id = ?
AND model_name = ?
ORDER BY timestamp ASC
`

type GetUsageSnapshotsInTimeWindowParams struct {
	Datetime       interface{} `json:"datetime"`
	OrganizationID string      `json:"organization_id"`
	ModelName      string      `json:"model_name"`
}

func (q *Queries) GetUsageSnapshotsInTimeWindow(ctx context.Context, arg GetUsageSnapshotsInTimeWindowParams) ([]UsageSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getUsageSnapshotsInTimeWindow, arg.Datetime, arg.OrganizationID, arg.ModelName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsageSnapshot
	for rows.Next() {
		var i UsageSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.OrganizationID,
			&i.ModelName,
			&i.TokensUsed,
			&i.TokensLimit,
			&i.TokensRemaining,
			&i.RequestsUsed,
			&i.RequestsLimit,
			&i.RequestsRemaining,
			&i.ResetRequestsSeconds,
			&i.ResetTokensSeconds,
			&i.DataSource,
			&i.IsComplete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAlert = `-- name: InsertAlert :exec
INSERT INTO alerts (
    timestamp,
    organization_id,
    model_name,
    alert_type,
    severity,
    metric_name,
    metric_value,
    threshold_value,
    message
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type InsertAlertParams struct {
	Timestamp      time.Time `json:"timestamp"`
	OrganizationID string    `json:"organization_id"`
	ModelName      string    `json:"model_name"`
	AlertType      string    `json:"alert_type"`
	Severity       string    `json:"severity"`
	MetricName     string    `json:"metric_name"`
	MetricValue    float64   `json:"metric_value"`
	ThresholdValue float64   `json:"threshold_value"`
	Message        *string   `json:"message"`
}

func (q *Queries) InsertAlert(ctx context.Context, arg InsertAlertParams) error {
	_, err := q.db.ExecContext(ctx, insertAlert,
		arg.Timestamp,
		arg.OrganizationID,
		arg.ModelName,
		arg.AlertType,
		arg.Severity,
		arg.MetricName,
		arg.MetricValue,
		arg.ThresholdValue,
		arg.Message,
	)
	return err
}

const insertBaselineAverage = `-- name: InsertBaselineAverage :exec
INSERT INTO baseline_averages (
    organization_id,
    model_name,
    time_window,
    avg_tokens_per_period,
    avg_requests_per_period,
    avg_burn_rate_tokens,
    std_deviation_tokens,
    std_deviation_requests,
    sample_count,
    period_days
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
ON CONFLICT (organization_id, model_name, time_window, period_days)
DO UPDATE SET
    avg_tokens_per_period = excluded.avg_tokens_per_period,
    avg_requests_per_period = excluded.avg_requests_per_period,
    avg_burn_rate_tokens = excluded.avg_burn_rate_tokens,
    std_deviation_tokens = excluded.std_deviation_tokens,
    std_deviation_requests = excluded.std_deviation_requests,
    sample_count = excluded.sample_count,
    last_updated = CURRENT_TIMESTAMP
`

type InsertBaselineAverageParams struct {
	OrganizationID       string   `json:"organization_id"`
	ModelName            string   `json:"model_name"`
	TimeWindow           string   `json:"time_window"`
	AvgTokensPerPeriod   *float64 `json:"avg_tokens_per_period"`
	AvgRequestsPerPeriod *float64 `json:"avg_requests_per_period"`
	AvgBurnRateTokens    *float64 `json:"avg_burn_rate_tokens"`
	StdDeviationTokens   *float64 `json:"std_deviation_tokens"`
	StdDeviationRequests *float64 `json:"std_deviation_requests"`
	SampleCount          *int64   `json:"sample_count"`
	PeriodDays           *int64   `json:"period_days"`
}

func (q *Queries) InsertBaselineAverage(ctx context.Context, arg InsertBaselineAverageParams) error {
	_, err := q.db.ExecContext(ctx, insertBaselineAverage,
		arg.OrganizationID,
		arg.ModelName,
		arg.TimeWindow,
		arg.AvgTokensPerPeriod,
		arg.AvgRequestsPerPeriod,
		arg.AvgBurnRateTokens,
		arg.StdDeviationTokens,
		arg.StdDeviationRequests,
		arg.SampleCount,
		arg.PeriodDays,
	)
	return err
}

const insertUsageMetrics = `-- name: InsertUsageMetrics :exec
INSERT INTO usage_metrics (
    timestamp,
    organization_id,
    model_name,
    time_window,
    total_tokens_used,
    total_requests_used,
    avg_burn_rate_tokens,
    peak_burn_rate_tokens,
    avg_burn_rate_requests,
    is_above_average,
    deviation_percentage,
    snapshot_count
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type InsertUsageMetricsParams struct {
	Timestamp           time.Time `json:"timestamp"`
	OrganizationID      string    `json:"organization_id"`
	ModelName           string    `json:"model_name"`
	TimeWindow          string    `json:"time_window"`
	TotalTokensUsed     *int64    `json:"total_tokens_used"`
	TotalRequestsUsed   *int64    `json:"total_requests_used"`
	AvgBurnRateTokens   *float64  `json:"avg_burn_rate_tokens"`
	PeakBurnRateTokens  *float64  `json:"peak_burn_rate_tokens"`
	AvgBurnRateRequests *float64  `json:"avg_burn_rate_requests"`
	IsAboveAverage      *bool     `json:"is_above_average"`
	DeviationPercentage *float64  `json:"deviation_percentage"`
	SnapshotCount       *int64    `json:"snapshot_count"`
}

func (q *Queries) InsertUsageMetrics(ctx context.Context, arg InsertUsageMetricsParams) error {
	_, err := q.db.ExecContext(ctx, insertUsageMetrics,
		arg.Timestamp,
		arg.OrganizationID,
		arg.ModelName,
		arg.TimeWindow,
		arg.TotalTokensUsed,
		arg.TotalRequestsUsed,
		arg.AvgBurnRateTokens,
		arg.PeakBurnRateTokens,
		arg.AvgBurnRateRequests,
		arg.IsAboveAverage,
		arg.DeviationPercentage,
		arg.SnapshotCount,
	)
	return err
}

const insertUsageSnapshot = `-- name: InsertUsageSnapshot :exec
INSERT INTO usage_snapshots (
    timestamp,
    organization_id,
    model_name,
    tokens_used,
    tokens_limit,
    tokens_remaining,
    requests_used,
    requests_limit,
    requests_remaining,
    reset_requests_seconds,
    reset_tokens_seconds,
    data_source,
    is_complete
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type InsertUsageSnapshotParams struct {
	Timestamp            time.Time `json:"timestamp"`
	OrganizationID       string    `json:"organization_id"`
	ModelName            string    `json:"model_name"`
	TokensUsed           *int64    `json:"tokens_used"`
	TokensLimit          *int64    `json:"tokens_limit"`
	TokensRemaining      *int64    `json:"tokens_remaining"`
	RequestsUsed         *int64    `json:"requests_used"`
	RequestsLimit        *int64    `json:"requests_limit"`
	RequestsRemaining    *int64    `json:"requests_remaining"`
	ResetRequestsSeconds *int64    `json:"reset_requests_seconds"`
	ResetTokensSeconds   *int64    `json:"reset_tokens_seconds"`
	DataSource           string    `json:"data_source"`
	IsComplete           *bool     `json:"is_complete"`
}

func (q *Queries) InsertUsageSnapshot(ctx context.Context, arg InsertUsageSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, insertUsageSnapshot,
		arg.Timestamp,
		arg.OrganizationID,
		arg.ModelName,
		arg.TokensUsed,
		arg.TokensLimit,
		arg.TokensRemaining,
		arg.RequestsUsed,
		arg.RequestsLimit,
		arg.RequestsRemaining,
		arg.ResetRequestsSeconds,
		arg.ResetTokensSeconds,
		arg.DataSource,
		arg.IsComplete,
	)
	return err
}
